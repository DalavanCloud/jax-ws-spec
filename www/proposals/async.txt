WSDL Definition
===============

<definitions name="foo"
    targetNamespace="http://xml.sun.com/ws/foo"
    xmlns:tns="http://xml.sun.com/ws/foo"
    xmlns="http://schemas.xmlsoap.org/wsdl/"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/">

  <message name="barRequest">
    <part name="p1" type="xsd:string"/>
    <part name="p2" type="xsd:string"/>
  </message>

  <message name="barResponse">
    <part name="p2" type="xsd:string"/>
    <part name="return" type="xsd:string"/>
  </message>

  <portType name="fooPort">
    <operation name="bar" parameterOrder="p1 p2">
      <input message="tns:barRequest"/>
      <output message="tns:barResponse"/>
    </operation>
  </portType>

  <binding name="fooBinding" type="tns:fooPort">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/>
    <operation name="bar">
      <soap:operation style="rpc"/>
      <input message="tns:barRequest">
        <soap:body use="literal" namespace="http://xml.sun.com/ws/foo" parts="p1 p2"/>
      </input>
      <output message="tns:barResponse">
        <soap:body use="literal" namespace="http://xml.sun.com/ws/foo" parts="p2 return"/>
      </output>
    </operation>
  </binding>

</definitions>


JAX-RPC 1.1 Mapping
===================

The WSDL above maps to the following Java interface using the rules JAX-RPC 1.1:

public interface FooPort extends java.rmi.Remote {
    java.lang.String bar(java.lang.String p1,
        javax.xml.rpc.holders.StringHolder p2)
        throws java.rmi.RemoteException;
}


Proposed Async Mapping
======================

We would generate two additional interfaces as follows:

public interface FooPortAsync extends FooPort {
    // polling version of bar method
    AsyncResponse<BarResponse> startBar(java.lang.String p1,
        java.lang.String p2) throws java.rmi.RemoteException;

    // callback version of bar method
    AsyncResponse<?> startBar(java.lang.String p1,
        java.lang.String p2, FooPortAsyncHandler h)
        throws java.rmi.RemoteException;
}

public interface FooPortAsyncHandler {
    void handleBar(BarResponse br);
    // require one fault handler per method or interface ?
    void handleFault(java.lang.Exception e);
}

where AsyncResponse is a generic class based on JSR 166 as follows

interface AsyncResponse<T> extends Future<T> extends Condition {
}

and BarResponse is an JAXB interface generated for the barResponse
message defined in the WSDL. BarResponse is effectively a wrapper for
all of the output of the method bar.

AsyncResponse<?> represents a typeless generic. The Object returned from
AsyncResponse<?>.get(...) has no standard type. Client code should not
attempt to cast the Object to any particular type as this will result in
non-portable behaviour.

The Condition component of AsyncResponse represents the same condition
that the thread waiting to perform a callback is waiting on. All threads
waiting on the condition are awakened at the same time.

JAXB Connection
===============

We're going to have to specify the contract between JAX-RPC and JAXB.
JAXB targets schema not WSDL so it seems natural for JAX-RPC to use JAXB
to generate marshallers and unmarshallers for message payloads rather
than messages themselves, i.e. for the contents of a SOAP Header and
Body rather than the actual SOAP Envelope.

For rpc/literal the WSDL types section doesn't actually contain a schema
for the message payload (as would be the case for doc/literal) but its
possible to derive one from the other WSDL constructs. The input to JAXB
in this example would be an XSD synthesized from the WSDL above and
would look something like

<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  elementFormDefault="qualified"
  targetNamespace="http://xml.sun.com/ws/foo">

    <xsd:element name="bar">
      <xsd:complexType>
        <xsd:sequence>
          <xsd:element form="unqualified" name="p1" type="xsd:string"/>
          <xsd:element form="unqualified" name="p2" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:element>

    <xsd:element name="barResponse">
      <xsd:complexType>
        <xsd:sequence>
          <xsd:element form="unqualified" name="p2" type="xsd:string"/>
          <xsd:element form="unqualified" name="return" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:element>

</xsd:schema>

Note that the global elements "bar" and "barResponse" are named after
the WSDL operation rather than the WSDL message.  WS-I BP 1.0
requirements R2712 and R2729 clarify the name of the payload root
element for doc/literal and rpc/literal bindings respectively.

The JAXB generated interfaces would be

public interface BarResponse
    extends javax.xml.bind.Element, com.sun.xml.ws.async.BarResponseType
{
}

public interface BarResponseType {
    java.lang.String getP2();
    void setP2(java.lang.String value);
    java.lang.String getReturn();
    void setReturn(java.lang.String value);
}


Usage Examples
==============

Usage 1: Polling with timeout

AsyncResponse<BarResponse> res = port.startBar("hello", "world");

// do something else for a while

BarResponse br = res.get(300, TimeUnit.MILLISECONDS);


Usage 2: Polling until finished

AsyncResponse<BarResponse> res = port.startBar("hello", "world");

while (!res.isDone()) {
  // do something else
}

BarResponse br = res.get();


Usage 3: Polling in a different thread

class ResponseThread extends Thread {
  AsyncResponse<BarResponse> res;
  ResponseThread(AsyncResponse<BarResponse> res) {
    this.res = res;
  }

  public void run() {
    if (res.await(300, TimeUnit.MILLISECONDS) == true) {
      // do something with the result
    }
    else {
      // operation timed out
    }
  }
}

AsyncResponse<BarResponse> res = port.startBar("hello", "world");
Thread responseThread = new ResponseThread(res);
// go on and let the new thread handle the response


Usage 4: Callback

class MyFooHandler implements FooPortAsyncHandler {
  FooHandlerContext fhc;
  public MyFooHandler(FooHandlerContext fhc) {
    this.fhc = fhc;
  }

  public void endBar(BarResponse br) {
    // do something with br
  }
  public void handleFault(Exception e) {
    // do something with e
  }
}

FooHandlerContext fhc = new FooHandlerContext(...);
FooPortAsyncHandler h = new MyFooHandler(fhc);
AsyncResponse<?> res = port.startBar("hello", "world", h);
// do something
if (!res.isDone()) {
  res.cancel(true);
}


Application to DII
==================

We can apply the same pattern described above to DII, the result is
similar to the proposal from Sunil if you substitute PollHandler for
AsyncResponse, CallbackHandler for CallAsyncHandler and AsyncResponse
for CallResponse.

public interface CallAsyncHandler {
    void handleResponse(CallResponse r);
    void handleFault(java.lang.Exception e, CallInspect i);
}

interface CallResult {
       java.util.Map getOutputParams();
       java.util.List getOutputValues();
       java.lang.Object getReturnValue();
}

interface CallInspect {
       boolean isParameterAndReturnSpecRequired(QName operationName);
       String getTargetEndpointAddress();
       Object getProperty(String name);
       java.util.Iterator getPropertyNames();
       QName getParameterTypeByName(String paramName);
       QName getReturnType();
       QName getOperationName();
       QName getPortTypeName();
}

interface CallSetup {
       void addParameter(String paramName,
               QName xmlType,
               ParameterMode parameterMode);
       void addParameter(String paramName,
               QName xmlType,
               Class javaType,
               ParameterMode parameterMode);
       void setReturnType(QName xmlType);
       void setReturnType(QName xmlType, Class javaType);
       void setProperty(String name, Object value);
       void removeAllParameters();
       void setOperationName(QName operationName);
       void setPortTypeName(QName portType);
       void setTargetEndpointAddress(String address);
       void removeProperty(String name);
}

interface Call extends CallSetup extends CallInspect extends CallResult
{
       Call clone(); 

       Object invoke(Object[] inputParams)
               throws java.rmi.RemoteException;
       Object invoke(QName operationName,
               Object[] inputParams)
               throws java.rmi.RemoteException;
       void invokeOneWay(Object[] inputParams);
}

interface CallResponse extends CallInspect extends CallResult{}

interface CallAsync extends CallSetup extends CallInspect {
       CallAsync clone();
        
       // polling versions of invoke methods
       AsyncResponse<CallResponse> invoke(
               java.lang.String operationName,
               Object[] params) throws java.rmi.RemoteException;
       AsyncResponse<CallResponse> invoke(
               Object[] params) throws java.rmi.RemoteException;
       // do we need async variation of invokeOneWay ?

       // callback version of invoke methods
       AsyncResponse<?> invoke(
               java.lang.String operationName,
               Object[] params,
               CallAsyncHandler h) throws java.rmi.RemoteException;
       AsyncResponse<?> invoke(
               Object[] params,
               CallAsyncHandler h) throws java.rmi.RemoteException;
}

CallInspect methods of a CallResponse instance are required to return
the state of the CallAsync instance that created them at the time of the
invoke. Use of the CallSetup methods of the CallAsync object after an
invoke does not change the values obtained from the CallInspect getter
methods of a previously created CallResponse.

The Object returned from AsyncResponse<?>.get(...) has no standard type.
Client code should not attempt to cast the Object to any particular
type as this will result in non-portable behaviour.

Call and CallAsync are not thread safe. Use of the same instance in
multiple threads requires considerable care - use of the clone() method
is recommended where multiple threads would like to  is required.


